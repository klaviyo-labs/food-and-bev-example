"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Klaviyo = exports.Auth = exports.Webhooks = exports.WebFeeds = exports.TrackingSettings = exports.Templates = exports.Tags = exports.Segments = exports.Reviews = exports.Reporting = exports.Profiles = exports.Metrics = exports.Lists = exports.Images = exports.Forms = exports.Flows = exports.Events = exports.DataPrivacy = exports.Coupons = exports.Catalogs = exports.Campaigns = exports.Accounts = exports.Pkce = exports.OAuthApi = exports.isKlaviyoTokenError = exports.KlaviyoTokenError = exports.KlaviyoErrorName = exports.OAuthBasicSession = exports.OAuthSession = exports.ConfigWrapper = exports.GlobalApiKeySession = exports.ApiKeySession = exports.GlobalApiKeySettings = exports.queryParamPreProcessor = exports.RetryWithExponentialBackoff = void 0;
__exportStar(require("./accountsApi"), exports);
const accountsApi_1 = require("./accountsApi");
__exportStar(require("./campaignsApi"), exports);
const campaignsApi_1 = require("./campaignsApi");
__exportStar(require("./catalogsApi"), exports);
const catalogsApi_1 = require("./catalogsApi");
__exportStar(require("./couponsApi"), exports);
const couponsApi_1 = require("./couponsApi");
__exportStar(require("./dataPrivacyApi"), exports);
const dataPrivacyApi_1 = require("./dataPrivacyApi");
__exportStar(require("./eventsApi"), exports);
const eventsApi_1 = require("./eventsApi");
__exportStar(require("./flowsApi"), exports);
const flowsApi_1 = require("./flowsApi");
__exportStar(require("./formsApi"), exports);
const formsApi_1 = require("./formsApi");
__exportStar(require("./imagesApi"), exports);
const imagesApi_1 = require("./imagesApi");
__exportStar(require("./listsApi"), exports);
const listsApi_1 = require("./listsApi");
__exportStar(require("./metricsApi"), exports);
const metricsApi_1 = require("./metricsApi");
__exportStar(require("./profilesApi"), exports);
const profilesApi_1 = require("./profilesApi");
__exportStar(require("./reportingApi"), exports);
const reportingApi_1 = require("./reportingApi");
__exportStar(require("./reviewsApi"), exports);
const reviewsApi_1 = require("./reviewsApi");
__exportStar(require("./segmentsApi"), exports);
const segmentsApi_1 = require("./segmentsApi");
__exportStar(require("./tagsApi"), exports);
const tagsApi_1 = require("./tagsApi");
__exportStar(require("./templatesApi"), exports);
const templatesApi_1 = require("./templatesApi");
__exportStar(require("./trackingSettingsApi"), exports);
const trackingSettingsApi_1 = require("./trackingSettingsApi");
__exportStar(require("./webFeedsApi"), exports);
const webFeedsApi_1 = require("./webFeedsApi");
__exportStar(require("./webhooksApi"), exports);
const webhooksApi_1 = require("./webhooksApi");
const axios = require('axios');
const axios_1 = require("axios");
const revision = "2025-04-15";
const userAgent = "klaviyo-api-node/18.0.0";
class RetryWithExponentialBackoff {
    constructor(config = {}) {
        this.baseInterval = 0.5;
        this.randFactor = 0.5;
        this.multiplier = 1.5;
        this.retryCodes = [429, 503, 504, 524];
        this.numRetries = 3;
        this.maxInterval = 60;
        if (config.retryCodes) {
            this.retryCodes = config.retryCodes;
        }
        if (config.numRetries !== undefined) {
            this.numRetries = config.numRetries;
        }
        if (config.maxInterval) {
            this.maxInterval = config.maxInterval;
        }
    }
    requestWithRetry(config) {
        return __awaiter(this, void 0, void 0, function* () {
            let lastRequestRetryAfter;
            let lastRequestTimestamp;
            let attempt = 0;
            let iteration = 0;
            while (true) {
                try {
                    const currentTime = Date.now();
                    const retryAfterValueLapsed = (!lastRequestRetryAfter ||
                        currentTime - lastRequestTimestamp > lastRequestRetryAfter);
                    if (retryAfterValueLapsed) {
                        attempt += 1;
                        const axiosResponse = yield axios(config);
                        return axiosResponse;
                    }
                }
                catch (error) {
                    if (!(0, axios_1.isAxiosError)(error) || !error.response || attempt >= this.numRetries) {
                        throw error;
                    }
                    const { status, headers } = error.response;
                    if (!this.retryCodes.includes(status)) {
                        throw error;
                    }
                    const responseHeaders = headers || {};
                    lastRequestRetryAfter = responseHeaders['Retry-After'];
                    if (lastRequestRetryAfter) {
                        lastRequestRetryAfter = parseInt(lastRequestRetryAfter, 10);
                    }
                    lastRequestTimestamp = Date.now();
                }
                const sleepSeconds = this.exponentialBackoff(iteration);
                yield this.sleep(sleepSeconds);
                iteration += 1;
            }
        });
    }
    exponentialBackoff(iteration) {
        const waitTime = Math.min(this.baseInterval * Math.pow(this.multiplier, iteration), this.maxInterval);
        // Apply randomness to avoid thundering herd
        const delta = this.randFactor * waitTime;
        const randomNeg1To1 = 2 * Math.random() - 1;
        return waitTime + delta * randomNeg1To1;
    }
    sleep(seconds) {
        return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
    }
}
exports.RetryWithExponentialBackoff = RetryWithExponentialBackoff;
function queryParamPreProcessor(queryParams) {
    if (queryParams['page[cursor]'] && queryParams['page[cursor]'].includes("https://")) {
        const params = new URLSearchParams(decodeURI(queryParams['page[cursor]'].split('?')[1]));
        queryParams['page[cursor]'] = params.get('page[cursor]');
    }
    for (const key in queryParams) {
        let value = queryParams[key];
        if (Array.isArray(value)) {
            queryParams[key] = value.join();
        }
    }
}
exports.queryParamPreProcessor = queryParamPreProcessor;
class GlobalApiKeySettings {
    constructor(apiKey, retryWithExponentialBackoff) {
        GlobalApiKeySettings.apiKey = apiKey;
        if (retryWithExponentialBackoff) {
            GlobalApiKeySettings.retryWithExponentialBackoff = retryWithExponentialBackoff;
        }
    }
}
exports.GlobalApiKeySettings = GlobalApiKeySettings;
GlobalApiKeySettings.retryWithExponentialBackoff = new RetryWithExponentialBackoff();
class ApiKeySession {
    constructor(apiKey, retryWithExponentialBackoff) {
        this._apiKeyPrefix = "Klaviyo-API-Key";
        this.retryWithExponentialBackoff = new RetryWithExponentialBackoff();
        this.apiKey = apiKey;
        if (retryWithExponentialBackoff) {
            this.retryWithExponentialBackoff = retryWithExponentialBackoff;
        }
        else {
            this.retryWithExponentialBackoff = new RetryWithExponentialBackoff();
        }
    }
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = `${this._apiKeyPrefix} ${this.apiKey}`;
            requestOptions.headers['User-Agent'] = userAgent;
            requestOptions.headers['revision'] = revision;
        }
    }
    requestWithRetry(config) {
        return this.retryWithExponentialBackoff.requestWithRetry(config);
    }
    refreshAndRetry(error, retried) {
        return false;
    }
}
exports.ApiKeySession = ApiKeySession;
class GlobalApiKeySession {
    constructor() {
        this._apiKeyPrefix = "Klaviyo-API-Key";
    }
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            if (GlobalApiKeySettings.apiKey) {
                requestOptions.headers["Authorization"] = `${this._apiKeyPrefix} ${GlobalApiKeySettings.apiKey}`;
                requestOptions.headers['User-Agent'] = userAgent;
                requestOptions.headers['revision'] = revision;
            }
            else {
                throw Error("No API Key set");
            }
        }
    }
    requestWithRetry(config) {
        return GlobalApiKeySettings.retryWithExponentialBackoff.requestWithRetry(config);
    }
    refreshAndRetry(error, retried) {
        return false;
    }
}
exports.GlobalApiKeySession = GlobalApiKeySession;
function ConfigWrapper(apiKey, opts = {}) {
    const retryWithExponentialBackoff = new RetryWithExponentialBackoff(opts);
    if (opts) {
        GlobalApiKeySettings.retryWithExponentialBackoff = retryWithExponentialBackoff;
    }
    GlobalApiKeySettings.apiKey = apiKey;
    return new ApiKeySession(apiKey, retryWithExponentialBackoff);
}
exports.ConfigWrapper = ConfigWrapper;
class OAuthSession {
    constructor(customerIdentifier, oAuthApi, retryWithExponentialBackoff = new RetryWithExponentialBackoff()) {
        this.customerIdentifier = customerIdentifier;
        this.oAuthApi = oAuthApi;
        this._prefix = "Bearer";
        this.retryWithExponentialBackoff = retryWithExponentialBackoff;
    }
    applyToRequest(requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            let tokens = yield this.oAuthApi.tokenStorage.retrieve(this.customerIdentifier);
            if (tokens.expiresAt) {
                if ((tokens.expiresAt.getTime() - new Date().getTime()) < (30 * 1000)) {
                    tokens = yield this.oAuthApi.refreshTokens(this.customerIdentifier, tokens.refreshToken);
                }
            }
            else if (!tokens.accessToken) {
                tokens = yield this.oAuthApi.refreshTokens(this.customerIdentifier, tokens.refreshToken);
            }
            if (requestOptions && requestOptions.headers) {
                requestOptions.headers["Authorization"] = `${this._prefix} ${tokens.accessToken}`;
                requestOptions.headers['User-Agent'] = userAgent;
                requestOptions.headers['revision'] = revision;
            }
        });
    }
    requestWithRetry(config) {
        return this.retryWithExponentialBackoff.requestWithRetry(config);
    }
    refreshAndRetry(error, retried) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!retried && (0, axios_1.isAxiosError)(error) && ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 401) {
                yield this.oAuthApi.refreshTokens(this.customerIdentifier);
                return true;
            }
            return false;
        });
    }
}
exports.OAuthSession = OAuthSession;
class OAuthBasicSession {
    constructor(accessToken, retryWithExponentialBackoff = new RetryWithExponentialBackoff()) {
        this._prefix = "Bearer";
        this.accessToken = accessToken;
        this.retryWithExponentialBackoff = retryWithExponentialBackoff;
    }
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = `${this._prefix} ${this.accessToken}`;
            requestOptions.headers['User-Agent'] = userAgent;
            requestOptions.headers['revision'] = revision;
        }
    }
    refreshAndRetry(error, retried) {
        return false;
    }
    requestWithRetry(config) {
        return this.retryWithExponentialBackoff.requestWithRetry(config);
    }
}
exports.OAuthBasicSession = OAuthBasicSession;
var KlaviyoErrorName;
(function (KlaviyoErrorName) {
    KlaviyoErrorName["saveError"] = "SAVE_TOKEN_ERROR";
    KlaviyoErrorName["createError"] = "CREATE_TOKEN_ERROR";
    KlaviyoErrorName["retrieveError"] = "RETRIEVE_TOKEN_ERROR";
    KlaviyoErrorName["refreshError"] = "REFRESH_TOKEN_ERROR";
})(KlaviyoErrorName = exports.KlaviyoErrorName || (exports.KlaviyoErrorName = {}));
class KlaviyoTokenError extends Error {
    constructor(name, message, cause) {
        super();
        this.name = name;
        this.message = message;
        this.cause = cause;
    }
}
exports.KlaviyoTokenError = KlaviyoTokenError;
function isKlaviyoTokenError(error) {
    return error.name !== undefined && Object.values(KlaviyoErrorName).includes(error.name);
}
exports.isKlaviyoTokenError = isKlaviyoTokenError;
class OAuthApi {
    constructor(clientId, clientSecret, tokenStorage) {
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.tokenStorage = tokenStorage;
        this.authorizeUrl = "https://klaviyo.com/oauth/authorize";
        this.tokenUrl = "https://a.klaviyo.com/oauth/token";
    }
    generateAuthorizeUrl(state, scopes, codeChallenge, redirectUrl) {
        const url = new URL(this.authorizeUrl);
        let querystring;
        try {
            querystring = require('node:querystring');
        }
        catch (e) {
            querystring = require('querystring');
        }
        const params = {
            response_type: "code",
            code_challenge_method: "S256",
            client_id: this.clientId,
            state: state,
            scope: scopes,
            redirect_uri: redirectUrl,
            code_challenge: codeChallenge,
        };
        url.search = querystring.encode(params);
        return url.toString();
    }
    createTokens(customerIdentifier, codeVerifier, authorizationCode, redirectUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestBody = {
                "grant_type": "authorization_code",
                "code": authorizationCode,
                "code_verifier": codeVerifier,
                "redirect_uri": redirectUrl
            };
            const requestConfig = {
                method: "POST",
                url: this.tokenUrl,
                headers: this.createHeaders(),
                data: requestBody,
            };
            const currentDate = new Date();
            let tokens;
            try {
                const axiosResponse = yield axios(requestConfig);
                tokens = {
                    accessToken: axiosResponse.data.access_token,
                    refreshToken: axiosResponse.data.refresh_token,
                    expiresAt: new Date(currentDate.getTime() + (axiosResponse.data.expires_in * 1000)),
                };
            }
            catch (error) {
                const message = this.populateErrorMessage(error, 'Failed to create token');
                throw new KlaviyoTokenError(KlaviyoErrorName.createError, message, error);
            }
            return this.saveToken(customerIdentifier, tokens);
        });
    }
    refreshTokens(customerIdentifier, refreshToken) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!refreshToken) {
                try {
                    const tokens = yield this.tokenStorage.retrieve(customerIdentifier);
                    refreshToken = tokens.refreshToken;
                }
                catch (error) {
                    const message = this.populateErrorMessage(error, "Failed to get refresh token");
                    throw new KlaviyoTokenError(KlaviyoErrorName.retrieveError, message, error);
                }
            }
            const requestBody = {
                "grant_type": "refresh_token",
                "refresh_token": refreshToken,
            };
            const requestConfig = {
                method: "POST",
                url: this.tokenUrl,
                headers: this.createHeaders(),
                data: requestBody,
            };
            const currentDate = new Date();
            let tokens;
            try {
                const axiosResponse = yield axios(requestConfig);
                tokens = {
                    accessToken: axiosResponse.data.access_token,
                    refreshToken: axiosResponse.data.refresh_token,
                    expiresAt: new Date(currentDate.getTime() + (axiosResponse.data.expires_in * 1000)),
                };
            }
            catch (error) {
                const message = this.populateErrorMessage(error, 'Failed to refresh token');
                throw new KlaviyoTokenError(KlaviyoErrorName.refreshError, message, error);
            }
            return this.saveToken(customerIdentifier, tokens);
        });
    }
    createHeaders() {
        const headers = new axios_1.AxiosHeaders();
        headers.set('content-type', 'application/x-www-form-urlencoded');
        const auth = Buffer.from(`${this.clientId}:${this.clientSecret}`).toString('base64');
        headers.set("Authorization", `Basic ${auth}`);
        headers.set("User-Agent", userAgent);
        return headers;
    }
    saveToken(customerIdentifier, tokens) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.tokenStorage.save(customerIdentifier, tokens);
                return tokens;
            }
            catch (error) {
                const message = this.populateErrorMessage(error, 'Failed to save token');
                throw new KlaviyoTokenError(KlaviyoErrorName.saveError, message, error);
            }
        });
    }
    populateErrorMessage(error, defaultMessage) {
        var _a, _b, _c, _d, _e, _f;
        let message = defaultMessage;
        if ((0, axios_1.isAxiosError)(error) && ((_b = (_a = error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) && typeof ((_d = (_c = error.response) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.error) === 'string') {
            message = (_f = (_e = error.response) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f.error;
        }
        else if (error && typeof error === 'object' && 'message' in error && error.message && typeof error.message === 'string') {
            message = error.message;
        }
        return message;
    }
}
exports.OAuthApi = OAuthApi;
var Pkce;
(function (Pkce) {
    function generateCodes() {
        let crypto;
        try {
            crypto = require('node:crypto');
        }
        catch (error) {
            crypto = require('crypto');
        }
        const base64URLEncode = (str) => {
            return str.toString('base64')
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        };
        const verifier = base64URLEncode(crypto.randomBytes(32));
        const sha256 = (buffer) => {
            return crypto.createHash('sha256').update(buffer).digest();
        };
        const challenge = base64URLEncode(sha256(verifier));
        return {
            codeVerifier: verifier,
            codeChallenge: challenge
        };
    }
    Pkce.generateCodes = generateCodes;
})(Pkce = exports.Pkce || (exports.Pkce = {}));
exports.Accounts = new accountsApi_1.AccountsApi(new GlobalApiKeySession());
exports.Campaigns = new campaignsApi_1.CampaignsApi(new GlobalApiKeySession());
exports.Catalogs = new catalogsApi_1.CatalogsApi(new GlobalApiKeySession());
exports.Coupons = new couponsApi_1.CouponsApi(new GlobalApiKeySession());
exports.DataPrivacy = new dataPrivacyApi_1.DataPrivacyApi(new GlobalApiKeySession());
exports.Events = new eventsApi_1.EventsApi(new GlobalApiKeySession());
exports.Flows = new flowsApi_1.FlowsApi(new GlobalApiKeySession());
exports.Forms = new formsApi_1.FormsApi(new GlobalApiKeySession());
exports.Images = new imagesApi_1.ImagesApi(new GlobalApiKeySession());
exports.Lists = new listsApi_1.ListsApi(new GlobalApiKeySession());
exports.Metrics = new metricsApi_1.MetricsApi(new GlobalApiKeySession());
exports.Profiles = new profilesApi_1.ProfilesApi(new GlobalApiKeySession());
exports.Reporting = new reportingApi_1.ReportingApi(new GlobalApiKeySession());
exports.Reviews = new reviewsApi_1.ReviewsApi(new GlobalApiKeySession());
exports.Segments = new segmentsApi_1.SegmentsApi(new GlobalApiKeySession());
exports.Tags = new tagsApi_1.TagsApi(new GlobalApiKeySession());
exports.Templates = new templatesApi_1.TemplatesApi(new GlobalApiKeySession());
exports.TrackingSettings = new trackingSettingsApi_1.TrackingSettingsApi(new GlobalApiKeySession());
exports.WebFeeds = new webFeedsApi_1.WebFeedsApi(new GlobalApiKeySession());
exports.Webhooks = new webhooksApi_1.WebhooksApi(new GlobalApiKeySession());
exports.Auth = {
    ApiKeySession,
    GlobalApiKeySession,
    GlobalApiKeySettings,
    RetryWithExponentialBackoff,
    OAuthApi,
    OAuthBasicSession,
    OAuthSession,
    Pkce,
};
exports.Klaviyo = { Auth: exports.Auth, AccountsApi: accountsApi_1.AccountsApi, Accounts: exports.Accounts, CampaignsApi: campaignsApi_1.CampaignsApi, Campaigns: exports.Campaigns, CatalogsApi: catalogsApi_1.CatalogsApi, Catalogs: exports.Catalogs, CouponsApi: couponsApi_1.CouponsApi, Coupons: exports.Coupons, DataPrivacyApi: dataPrivacyApi_1.DataPrivacyApi, DataPrivacy: exports.DataPrivacy, EventsApi: eventsApi_1.EventsApi, Events: exports.Events, FlowsApi: flowsApi_1.FlowsApi, Flows: exports.Flows, FormsApi: formsApi_1.FormsApi, Forms: exports.Forms, ImagesApi: imagesApi_1.ImagesApi, Images: exports.Images, ListsApi: listsApi_1.ListsApi, Lists: exports.Lists, MetricsApi: metricsApi_1.MetricsApi, Metrics: exports.Metrics, ProfilesApi: profilesApi_1.ProfilesApi, Profiles: exports.Profiles, ReportingApi: reportingApi_1.ReportingApi, Reporting: exports.Reporting, ReviewsApi: reviewsApi_1.ReviewsApi, Reviews: exports.Reviews, SegmentsApi: segmentsApi_1.SegmentsApi, Segments: exports.Segments, TagsApi: tagsApi_1.TagsApi, Tags: exports.Tags, TemplatesApi: templatesApi_1.TemplatesApi, Templates: exports.Templates, TrackingSettingsApi: trackingSettingsApi_1.TrackingSettingsApi, TrackingSettings: exports.TrackingSettings, WebFeedsApi: webFeedsApi_1.WebFeedsApi, WebFeeds: exports.WebFeeds, WebhooksApi: webhooksApi_1.WebhooksApi, Webhooks: exports.Webhooks };
//# sourceMappingURL=apis.js.map